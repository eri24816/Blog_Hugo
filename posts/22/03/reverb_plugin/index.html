<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Reverb plugin |
eri24816's blog</title><meta name=description content="[<i>「如果恐怖片很恐怖，那就不要看恐怖片。」<div style=&#34;text-align: right; max-width: 500px; margin-top: 20px;&#34; ></i>- eri24816</div> <i>Chase excellence, success will follow.</i> 在我的這個環境裡，這麼做是極為危險的。 希望在大學的壓力下不要丟失我的初衷。<br/>那就是：我喜愛這個世界，所以想以最 high level 的角度理解世界，幫各種我喜歡的東西建立模型。像是音樂生成模型、style transfer、物理模擬。]"><meta name=author content><link rel=apple-touch-icon href=/apple-touch-icon.png sizes=180x180><link rel=icon href=/favicon-32x32.png sizes=32x32 type=image/png><link rel=icon href=/favicon-16x16.png sizes=16x16 type=image/png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#0c344b><link rel=icon href=/favicon.ico><link rel=stylesheet href=/dist/main.37ab3f61b95417873748.min.css><link rel=stylesheet href=/css/custom.css><link href="https://fonts.googleapis.com/css?family=Raleway" rel=stylesheet><link rel=stylesheet href=https://eri24816.github.io/styles.bbf10ba610038231b00aafbedcf3e8ffb55c242102b3b1359aa7fc98e30e6ad0.css><link rel=canonical href=https://eri24816.github.io/posts/22/03/reverb_plugin/><meta property="og:title" content="Reverb plugin"><meta property="og:description" content="一直想做的東西後來真的有課教我怎麼做，就會覺得那個課很棒。
在「數位音樂訊號分析」這門課中，十幾個學生分成6組，每組使用 JUCE(一個製作 VST 的 C++ 框架)來做一種 VST 效果器。我們這組做的是 reverb。Reverb 的功用是把音樂加上迴音，像是在大教堂或音樂廳的感覺。"><meta property="og:type" content="article"><meta property="og:url" content="https://eri24816.github.io/posts/22/03/reverb_plugin/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-16T17:33:37+08:00"><meta property="article:modified_time" content="2022-03-16T17:33:37+08:00"><meta itemprop=name content="Reverb plugin"><meta itemprop=description content="一直想做的東西後來真的有課教我怎麼做，就會覺得那個課很棒。
在「數位音樂訊號分析」這門課中，十幾個學生分成6組，每組使用 JUCE(一個製作 VST 的 C++ 框架)來做一種 VST 效果器。我們這組做的是 reverb。Reverb 的功用是把音樂加上迴音，像是在大教堂或音樂廳的感覺。"><meta itemprop=datePublished content="2022-03-16T17:33:37+08:00"><meta itemprop=dateModified content="2022-03-16T17:33:37+08:00"><meta itemprop=wordCount content="540"><meta itemprop=keywords content="c++,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reverb plugin"><meta name=twitter:description content="一直想做的東西後來真的有課教我怎麼做，就會覺得那個課很棒。
在「數位音樂訊號分析」這門課中，十幾個學生分成6組，每組使用 JUCE(一個製作 VST 的 C++ 框架)來做一種 VST 效果器。我們這組做的是 reverb。Reverb 的功用是把音樂加上迴音，像是在大教堂或音樂廳的感覺。"><script src=https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js type=text/javascript></script></head><body><nav class="navbar navbar-expand-md navbar-light bg-light fixed-top shadow-sm" id=navbar-main-menu><div class=container><a class="navbar-brand font-weight-bold" href=https://eri24816.github.io/>eri24816's blog</a>
<a class="navbar-brand font-weight-bold" href=https://eri24816.github.io//categories/>Categories</a>
<a class="navbar-brand font-weight-bold" href=https://eri24816.github.io//tags/>Tags</a>
<a class="navbar-brand font-weight-bold" href=https://github.com/eri24816/eri24816.github.io>Source</a>
<a class="navbar-brand font-weight-bold" href=https://github.com/eri24816/>My github</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#main-menu aria-controls=main-menu aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=main-menu><ul class="navbar-nav ml-auto"></ul></div></div></nav><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><main class="content-page container pt-9 pb-5"><div class=row><div class=col><article><div class="row justify-content-center"><div class=col-lg-8><div class="meta text-muted mb-3"><p class="created text-muted text-uppercase font-weight-bold mb-1">March 16, 2022</p></div><a href=/categories/music>music ></a><h1>Reverb plugin</h1></div></div><div class="row justify-content-center"><div class=col-lg-8><div class=content><p>一直想做的東西後來真的有課教我怎麼做，就會覺得那個課很棒。</p><p>在「數位音樂訊號分析」這門課中，十幾個學生分成6組，每組使用 JUCE(一個製作 VST 的 C++ 框架)來做一種 VST 效果器。我們這組做的是 reverb。Reverb 的功用是把音樂加上迴音，像是在大教堂或音樂廳的感覺。</p><p>這門課是我這一年遇過最好玩的。我學到非常多好玩的觀念，像是 z transform、怎麼看 zero pole plot、如何用 C++ 來 OOP (踩各種指標的坑XD)。</p><h2 id=整體架構>整體架構</h2><p>下圖是我們一開始參考的架構。</p><p><img src=https://i.imgur.com/gLgWwXH.jpg#center alt=Image>
<a href=https://ccrma.stanford.edu/~jos/pasp/Zita_Rev1.html>https://ccrma.stanford.edu/~jos/pasp/Zita_Rev1.html</a></p><p>首先，輸入的 2 個 channel 被一個 2*8 matrix 分成 8 個 channel，接著進入迴圈。迴圈裡都是 8 個 channel 在跑，訊號會依序經過 allpass、feedback matrix、lowpass、delay line 四個基礎 filter，然後重複。在 feedback matrix 後面有一條脫離迴圈的輸出路徑，會經過一個 8*2 的 matrix，輸出到 2 個 channel。</p><p>這看似簡單(我們只要把每個基本模組實做出來即可)，但困難點在於這兩項性質難以同時兼顧:</p><ol><li>產生的聲音好聽</li><li>IIR的穩定性</li></ol><p>這是因為我們使用的是帶有迴圈的 IIR，所以參數沒調好的話會不穩定 (unstable)。如果使用的是 FIR 則能免除這項困難，但是如果用 FIR 做 reverb，計算量會太大。所以在建好架構後，我們花了大半的時間在嘗試找出在 IIR 穩定的情況下，聲音最好聽的參數。</p><h2 id=各模組的實作>各模組的實作</h2><p>在我們的實作中有很多種模組 (例如 DelayLine，LowPass)，每種模組都是一個多 channel 的 causal filter。一個大模組裡面可能包含數個小模組，而完整的 Reverb 本身就是一個最大的模組。</p><p>每種模組皆有實作方法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> update(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input)
</code></pre></div><p>在 VST 的每一個 time step，這個方法都會收到一個 float 陣列作為輸入，計算完後輸出一個 float 陣列。大部分的模組都具有 memory，所以 update() 方法不是 time independent 的。</p><h3 id=delayline>DelayLine</h3><p>DelayLine 的功能單純就是在收到訊號後延遲數個 sample 的時間再輸出，在頻域上的作用為$z^{-n}$。用 std::queue 就可以簡單地把它實做出來。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input) <span style=color:#66d9ef>override</span>{
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> inputDim; i<span style=color:#f92672>++</span>) {
        queues[i].push(input[i]);
        outputBuffer[i] <span style=color:#f92672>=</span> queues[i].front();
        queues[i].pop();
    }
    <span style=color:#66d9ef>return</span> outputBuffer;
}
</code></pre></div><p>後來為了減少耗時，我又自己刻了一個沒有用到 std::queue 的版本。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input) <span style=color:#66d9ef>override</span> {
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> inputDim; i<span style=color:#f92672>++</span>) {
        outputBuffer[i] <span style=color:#f92672>=</span> arr[i][pos[i]];
        arr[i][pos[i]] <span style=color:#f92672>=</span> input[i];
        pos[i]<span style=color:#f92672>++</span>;
        <span style=color:#66d9ef>if</span> (pos[i] <span style=color:#f92672>==</span> len[i])pos[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    }
    <span style=color:#66d9ef>return</span> outputBuffer;
}
</code></pre></div><h3 id=lowpass>Lowpass</h3><p>這個模組是一階 low pass filter，頻域上的作用為$(1-a)+az^{-1}$。</p><p>實作的方法是把前一個輸出以某個權重加回當前的輸入，以此作為輸出。也就是在波型上做 smoothing。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input) <span style=color:#66d9ef>override</span> {
    mult(inputDim, input, <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> a);
    mult(inputDim, feedback, a);
    add(inputDim, input, feedback);
    copy(inputDim, feedback, input);
    <span style=color:#66d9ef>return</span> mult(inputDim, input,<span style=color:#ae81ff>1</span>);
}
<span style=color:#75715e>// 這些 code 長得很像 assembly 是因為我沒有定義 vector 這個 class 和它的 operators，
</span><span style=color:#75715e>// 只有草率定義了幾個對 float 陣列的運算。我當時太懶了XD
</span></code></pre></div><p>a 是調控 cutoff frequency 的參數，它們的關係是:
$$a=e^{-2\pi \frac{ \mathit{Cutoff}} {\mathit{SampleRate}}}$$</p><h3 id=allpass>Allpass</h3><p>它是二階的 all pass filter。這是這個 project 最難做的 filter，我們必須由該 filter 應具有的性質，推導出實作的方法。</p><p>二階 all pass filter 的 pole-zero plot 有兩個 poles 和兩個 zeros，且此 filter 的性質受到以下限制:</p><ol><li>根據 complex conjugate root theorem，兩個 poles(zeros) 必共軛</li><li>為了讓各頻率的 amplitude response 皆維持在 1，每個 pole 對單位圓的反演處必須有一個 zero，反之亦然</li></ol><p>結合這兩項限制，代表我們只需要一組參數 $(r,θ)$ 來控制某一個 pole 的位置，即可以決定所有 pole 和 zero 的位置，也決定了這個二階 filter。</p><p><img src=https://i.imgur.com/4HVI7Xu.png#centers alt=Image></p><p>接下來就是用 $(r,θ)$ 來推出 IIR 的結構。</p><p>設此 filter 的 response 為 $H(z)=\frac{P(z)}{Q(z)}$，$P$ 的兩根為 zero，$Q$ 的兩根為 pole。以此為出發點，P 和 Q 為:<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>$$\begin{aligned}
P(z) &= r^2(z-r^{-1}e^{iθ}) (z-r^{-1}e^{-iθ}) \\<br>&=r^2z^2-r(e^{iθ}+e^{-iθ})z+1\\<br>&=r^2z^2-2r\cos(θ)z+1
\end{aligned}$$</p><p>$$\begin{aligned}
Q(z)&=(z-re^{iθ})(z-re^{-iθ})\\<br>&=z^2-r(e^{iθ}+e^{-iθ})z+r^2\\<br>&=z^2-2r\cos(θ)z+r^2
\end{aligned}$$</p><p>令$X(z)$為輸入，$Y(z)$為輸出:
$$\begin{aligned}
Y(z)&=H(z)X(z)\\<br>&=\frac{P(z)}{Q(z)}X(z)\\<br>\end{aligned}$$</p><p>$$\begin{aligned}
Q(z)Y(z)&=P(z)X(z)\\<br>(z^2-2r\cos(θ)z+r^2)Y(z)&=(r^2z^2-2r\cos(θ)z+1)X(z)\\<br>(1-2r\cos(θ)z^{-1}+r^2z^{-2})Y(z)&=(r^2-2r\cos(θ)z^{-1}+z^{-2})X(z)\\<br>\end{aligned}$$</p><p>經過移項，最後可以得到以下 difference equation:
$$y[n] = r^2 * x[n]-2r\cos(θ) * x[n-1]+x[n-2]+2r \cos(θ) * y[n-1]-r^2* y[n-2]$$</p><p>其中，$x[n]$為目前輸入的 sample，$y[n]$為目前欲輸出的 sample。因為計算 $y[n]$ 會用到 4 個以前的值，所以此 filter 需要 4 條 delay line(或 4 個 memory)。實作如下:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input)<span style=color:#66d9ef>override</span> {
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>inputDim;i<span style=color:#f92672>++</span>) {
        output[i] <span style=color:#f92672>=</span> R2[i] <span style=color:#f92672>*</span> input[i] <span style=color:#f92672>-</span> twoRCosTheta[i] <span style=color:#f92672>*</span> x1[i] <span style=color:#f92672>+</span> x2[i] <span style=color:#f92672>+</span> twoRCosTheta[i] <span style=color:#f92672>*</span> y1[i] <span style=color:#f92672>-</span> R2[i]<span style=color:#f92672>*</span>y2[i];

        x2[i] <span style=color:#f92672>=</span> x1[i];
        x1[i] <span style=color:#f92672>=</span> input[i];

        y2[i] <span style=color:#f92672>=</span> y1[i];
        y1[i] <span style=color:#f92672>=</span> output[i];
    }
    <span style=color:#66d9ef>return</span> output;
}
</code></pre></div><h3 id=comb>Comb</h3><p>Comb 超簡單，因為它是 FIR，沒有 feedback:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input)<span style=color:#66d9ef>override</span> {
    add(inputDim, input, delay.update(input));
    <span style=color:#66d9ef>return</span> input;
}
</code></pre></div><p><img src=https://i.imgur.com/u0USmfH.png#centers alt=Image></p><p>(但其實這個沒有用到，我們用 all pass 代替它了</p><h3 id=reverb>Reverb</h3><p>Reverb 這個最大的 filter 就是把所有小 filter 組裝起來。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> input) <span style=color:#66d9ef>override</span>{
    
    <span style=color:#66d9ef>float</span> dry[<span style=color:#ae81ff>2</span>];
    copy(inputDim, dry, input);

    input <span style=color:#f92672>=</span> distrib <span style=color:#f92672>*</span> inDelay.update(input);

    delayFilters.update(feedBack);

    add(NCH,input, fbDelayLine.update(feedBack));

    input <span style=color:#f92672>=</span> allpass.update(input);

    input <span style=color:#f92672>=</span> mult(inputDim, input, _decay);

    <span style=color:#66d9ef>float</span><span style=color:#f92672>*</span> output <span style=color:#f92672>=</span> feedbackmatrix <span style=color:#f92672>*</span> input;

    copy(NCH,feedBack, output);

    <span style=color:#66d9ef>return</span> dcBlocker.update(add(inputDim,mult(inputDim,outDistrib<span style=color:#f92672>*</span>output,wetAmount), mult(inputDim, dry,dryAmount)));
}
</code></pre></div><h2 id=調整參數>調整參數</h2><p>把所有 filter 組裝起來之後，我們遇到的第一個問題是跑了一段時間後數值很容易爆炸。這是因為在主迴圈中，如果有某個頻率的 amplitude response 超過 1，經過數次遞迴，那個頻率的強度就會指數發散。</p><p>我們隨即調低迴圈的 feedback matrix 的值，使得 amplitude response 下降。這時又出現另一個問題:殘響時間不夠長。當迴圈的 amplitude response 小於 1 太多，經過數次遞迴，聲音就會快速衰減並消失。</p><p>也就是說，必須讓每種頻率的 amplitude response 都小於 1，但只能小一點點。</p><p>後來我們找到的作法是:</p><ol><li>low pass 的 amplitude response 小於等於 1</li><li>all pass 的 amplitude response 等於 1 (當然)</li><li>feedback matrix 的每個 row 絕對值總和稍微小於 1</li></ol><p>這樣的話就可以保證不會爆炸了。原因如下:
以最嚴格的情況來看，假設 low pass 和 all pass 的 amplitude response 都是 1，訊號從 feedback matrix 的輸出繞一圈回到 feedback matrix 前的 amplitude 增益就是 1，強度不變。而 feedback matrix 會將 8 個 channel 重新混合，feedback matrix 的每個 row 絕對值總和小於 1 這項限制保證了混合後的訊號不會因疊加而增強。</p><p>不過因為訊號繞了一圈後，會發生複雜的項位改變，就算 feedback matrix 每個 row 絕對值總和非常接近 1，訊號卻很容易因為破壞性疊加而有很大的衰減率。而且 VST 的 sample rate 非常高(例如44100Hz)，所以還是會有不到 1 秒聲音就幾乎不見的情況。</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>國中學了但從未用過的根與係數終於在這裡用到了，覺得國中很浪費時間的心情稍稍下降了一點。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>第一行的 $r^2$ 用於 normalize&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><div class="tags my-3"><a class="badge badge-pill badge-light border mr-2" href=/tags/c++><i class="fas fa-tag mr-2"></i>c++</a></div><ul class="share nav my-3 justify-content-end"><li class=nav-item><a class=nav-link target=_blank href="https://twitter.com/intent/tweet?url=https%3a%2f%2feri24816.github.io%2fposts%2f22%2f03%2freverb_plugin%2f&text=Reverb%20plugin"><i class="fa-fw fab fa-twitter"></i></a></li><li class=nav-item><a class=nav-link target=_blank href="https://www.linkedin.com/shareArticle?url=https%3a%2f%2feri24816.github.io%2fposts%2f22%2f03%2freverb_plugin%2f&title=Reverb%20plugin"><i class="fa-fw fab fa-linkedin-in"></i></a></li><li class=nav-item><a class=nav-link target=_blank href="https://www.facebook.com/sharer.php?u=https%3a%2f%2feri24816.github.io%2fposts%2f22%2f03%2freverb_plugin%2f&t=Reverb%20plugin"><i class="fa-fw fab fa-facebook-f"></i></a></li><li class=nav-item><a class=nav-link target=_blank href="https://reddit.com/submit?url=https%3a%2f%2feri24816.github.io%2fposts%2f22%2f03%2freverb_plugin%2f&title=Reverb%20plugin"><i class="fa-fw fab fa-reddit-alien"></i></a></li></nav></div></div><div class="row justify-content-center"><div class=col-lg-8></div></div></article></div></div></main><footer class="footer text-center bg-dark py-6"><div class=container><div class=row><div class=col><ul class=list-inline></ul><p class=text-muted>Copyright &copy; eri24816's blog 2022</p><p class=text-muted>Powered by <a href=https://gohugo.io target=_blank>Hugo</a> with <a href=https://github.com/puresyntax71/hugo-theme-chunky-poster target=_blank>Chunky Poster</a>.</p></div></div></div></footer><script src=/dist/main.d608eadfe5ac0688902e.min.js></script><script src=/js/custom.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-WKQTFGNJW6"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-WKQTFGNJW6',{anonymize_ip:!1})}</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-WKQTFGNJW6','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>